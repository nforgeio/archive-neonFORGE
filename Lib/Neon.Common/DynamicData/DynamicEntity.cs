//-----------------------------------------------------------------------------
// FILE:	    DynamicEntity.cs
// CONTRIBUTOR: Jeff Lill
// COPYRIGHT:	Copyright (c) 2016-2019 by neonFORGE, LLC.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;

using Newtonsoft.Json.Linq;

using Neon.Common;
using Neon.DynamicData;
using Neon.DynamicData.Internal;

namespace Neon.DynamicData
{
    /// <summary>
    /// An implementation of <see cref="IDynamicEntity"/> suitable for backing
    /// most entity implementations, including those generated by the
    /// <c>entity-gen</c> tool.
    /// </summary>
    /// <threadsafety instance="false"/>
    public abstract class DynamicEntity : NotifyPropertyChanged, IDynamicEntity
    {
        //---------------------------------------------------------------------
        // Private types

        private struct CreateInfo
        {
            public EntityCreateDelegate Creator;
            public Type                 EntityType;
        }

        //---------------------------------------------------------------------
        // Static members

        private static object   syncRoot      = new object();
        private static char[]   colonSplitter = new char[] { ':' };

        // WARNING:
        //
        // Ensure that the property name definitions below do not conflict with
        // Neon Couchbase Lite extensions.

        /// <summary>
        /// The default property name to be used for entity type properties that
        /// don't have an explict name set in their <see cref="DynamicEntityPropertyAttribute"/>.
        /// </summary>
        public const string EntityTypeName = "+t";

        /// <summary>
        /// The internal entity property name used to persist an entity's full
        /// type inheritance path.
        /// </summary>
        public const string EntityTypePathName = "+tp";

        /// <summary>
        /// Dictionary mapping entity types to the delegate that can instantiate the entity.
        /// </summary>
        private static Dictionary<Type, EntityCreateDelegate> typeToEntityCreator
            = new Dictionary<Type, EntityCreateDelegate>();

        /// <summary>
        /// Dictionary mapping unique entity type identifer strings to the information
        /// we can use to instantiate the entity.
        /// </summary>
        private static Dictionary<string, CreateInfo> typeIdentifierToEntityCreator
            = new Dictionary<string, CreateInfo>();

        /// <summary>
        /// Registers entity types so they can be instantiated.
        /// </summary>
        /// <param name="registrations">The information about the entities being registered.</param>
        public static void Register(IEnumerable<EntityRegistration> registrations)
        {
            Covenant.Requires<ArgumentNullException>(registrations != null);

            lock (syncRoot)
            {
                // Make a copy of the current registration tables so add the
                // new registrations to the copy without impacting entities
                // being created on other threads.

                var copiedTypeToEntityCreator           = new Dictionary<Type, EntityCreateDelegate>();
                var copiedTypeIdentifierToEntityCreator = new Dictionary<string, CreateInfo>();

                foreach (var item in typeToEntityCreator)
                {
                    copiedTypeToEntityCreator.Add(item.Key, item.Value);
                }

                foreach (var item in typeIdentifierToEntityCreator)
                {
                    copiedTypeIdentifierToEntityCreator.Add(item.Key, item.Value);
                }

                // Merge the new registrations into the copied tables.

                foreach (var registration in registrations)
                {
                    copiedTypeToEntityCreator[registration.EntityType] = registration.Creator;

                    if (registration.TypeIdentifier != null)
                    {
                        CreateInfo info;

                        if (copiedTypeIdentifierToEntityCreator.TryGetValue(registration.TypeIdentifier, out info) && info.EntityType != registration.EntityType)
                        {
                            throw new ArgumentException($"Cannot register [{registration.EntityType.FullName}] because [{registration.TypeIdentifier}] is already registered by [{info.EntityType.FullName}].  Entity type identifiers must be unique within your application domain.");
                        }

                        copiedTypeIdentifierToEntityCreator[registration.TypeIdentifier]
                            = new CreateInfo()
                            {
                                EntityType = registration.EntityType,
                                Creator    = registration.Creator
                            };
                    }
                }

                // Swap the modified tables in to make them active.

                typeToEntityCreator           = copiedTypeToEntityCreator;
                typeIdentifierToEntityCreator = copiedTypeIdentifierToEntityCreator;
            }
        }
        
        /// <summary>
        /// Constructs a <typeparamref name="TEntity"/> from a <see cref="JObject"/>.
        /// </summary>
        /// <typeparam name="TEntity">The entity type.</typeparam>
        /// <param name="jObject">The backing <see cref="JObject"/>.</param>
        /// <param name="context">The <see cref="IDynamicEntityContext"/> or <c>null</c>.</param>
        /// <returns>The new <typeparamref name="TEntity"/>.</returns>
        /// <remarks>
        /// <para>
        /// This method is capable of instantiating derived entities in a future-proof 
        /// manner.  This is possible for entities whose defining <c>interface</c>s were
        /// tagged with a <see cref="DynamicEntityAttribute.Type"/> value.  This is
        /// set to a unique identifier for the type within the application domain. 
        /// </para>
        /// <para>
        /// Entities serialize their own type identifier as well as the 
        /// identifiers for any inherited types to the internal <see cref="DynamicEntity.EntityTypePathName"/>
        /// JSON property.  The type identifiers are formatted into a list of
        /// colon (<b>:</b>) separated values with the current type's identifier 
        /// listed first, followed by its parent's identifier and so on, all the 
        /// way to the root entity's identifier.
        /// </para>
        /// <para>
        /// This identifier list provides the information necessary to dynamically
        /// instantiate the derived entity that best fits the data.  For example,
        /// say you release a product that defines a base <c>IProduct</c> interface
        /// with <c>ICandy</c> derived from it.  IProduct defines a <b>Name</b> as
        /// property and ICandy adds <b>Calories</b>.
        /// </para>
        /// <para>
        /// An application can persist a base IProduct instance to the database
        /// as well as a derived ICandy.  Calling this method to load the base
        /// IProduct or ICandy document will simply load it.  Calling this method
        /// to load IProduct but passing the ICandy document, will actually create
        /// an ICandy instance but return it cast to the base type (IProduct).
        /// </para>
        /// <para>
        /// Applications can test entity types using the usual C# <c>is</c>/<c>as</c>
        /// operators or switch on the entity's type property, if one was tagged
        /// using <see cref="DynamicEntityPropertyAttribute.IsTypeProperty"/>.
        /// </para>
        /// <para>
        /// This also enables future-proofing.  Say version 1.0 of an application only
        /// knew about IProduct and ICandy.  Then, version 2.0 is released that adds
        /// <c>IBeer</c> which also derives from IProduct and persists some beer to
        /// a database.  Loading an IBeer document as an IProduct from version 1.0 
        /// will still work, even though v1 is not aware of this type.  An IProduct
        /// entity will be returned (what else can be done), but the IBeer properties
        /// will still be loaded into the underlying <c>JObject</c>.
        /// </para>
        /// </remarks>
        public static TEntity Create<TEntity>(JObject jObject, IDynamicEntityContext context)
            where TEntity : class, IDynamicEntity, new()
        {
            Covenant.Requires<ArgumentNullException>(jObject != null);

            EntityCreateDelegate    creator  = null;
            string[]                typePath = null;
            JToken                  typePathToken;
            CreateInfo              createInfo;

            if (jObject.TryGetValue(EntityTypePathName, out typePathToken) && typePathToken.Type == JTokenType.String)
            {
                typePath = ((string)typePathToken).Split(colonSplitter);
            }

            var hasTypePath = typePath != null && typePath.Length > 0;

            if (!hasTypePath)
            {
                // The document doesn't have a type path property so we're going to
                // use the creator registered for the type.

                typeToEntityCreator.TryGetValue(typeof(TEntity), out creator);
            }
            else
            {
                // Try each type identifier from the beginning of the path and use the
                // first registered creator we can find.  This will return the derived
                // class that best fits the data.

                foreach (var typeIdentifier in typePath)
                {
                    if (typeIdentifierToEntityCreator.TryGetValue(typeIdentifier, out createInfo))
                    {
                        creator = createInfo.Creator;
                        break;
                    }
                }
            }

            if (creator == null)
            {
                if (hasTypePath)
                {
                    throw new InvalidOperationException($"Entity type [{typeof(TEntity).FullName }] has not registered an entity creation function.  Make sure you have registered the generated entities and binder document types.");
                }
                else
                {
                    throw new InvalidOperationException($"Could not map any type from the [{typePath}] type path to an entity type.  Make sure you have registered the generated entities and binder document types.");
                }
            }

            var untypedEntity = creator(jObject, context);

            if (untypedEntity == null)
            {
                return null;
            }

            var entity = untypedEntity as TEntity;

            if (entity == null)
            {
                throw new InvalidCastException($"Unable to cast [{untypedEntity.GetType().FullName}] to [{typeof(TEntity).FullName}].  Possible data corruption or invalid type path [{typePath}].");
            }

            return entity;
        }

        //---------------------------------------------------------------------
        // Instance members

        private IDynamicEntity                  self;               // This instance cast to an [IDynamicEntity]
        private IDynamicEntity                  parent;             // The parent [IDynamicEntity] or NULL
        private IDictionary<string, string>     propertyNameMap;    // Maps JSON property names to entity names
        private IDynamicEntityContext           context;            // The optional entity context
        private string                          link;               // The entity link string or NULL

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="propertyNameMap">
        /// The dictionary mapping JSON property names to their entity equivalents.
        /// </param>
        /// <param name="context">The optional entity context.</param>
        public DynamicEntity(IDictionary<string, string> propertyNameMap, IDynamicEntityContext context = null)
        {
            Covenant.Requires<ArgumentNullException>(propertyNameMap != null);

            this.propertyNameMap = propertyNameMap;
            this.context         = context;
            this.self            = (IDynamicEntity)this;
            this.parent          = null;
        }

        /// <inheritdoc/>
        public abstract string _GetEntityType();

        /// <summary>
        /// Returns the <see cref="JObject"/> instance being used to back the object's properties.
        /// </summary>
        public JObject JObject { get; private set; }

        /// <inheritdoc/>
        public void _SetLink(string link)
        {
            Covenant.Requires<ArgumentNullException>(!string.IsNullOrEmpty(link));
            Covenant.Requires<InvalidOperationException>(this._GetLink() == null, "Entity links are invariant and cannot be modified once assigned.");

            this.link = link;
        }

        /// <inheritdoc/>
        public string _GetLink()
        {
            return link;
        }

        /// <inheritdoc/>
        public event EventHandler<EventArgs> Changed;

        /// <inheritdoc/>
        public void _Attach(IDynamicEntity parent)
        {
            Covenant.Requires<ArgumentNullException>(this.parent != null);

            if (this.parent != null && !object.ReferenceEquals(this.parent, this.parent))
            {
                throw new InvalidOperationException($"Cannot attach an [{nameof(IDynamicEntity)}] here when it is already attached elsewhere.");
            }

            this.parent = parent;
        }

        /// <inheritdoc/>
        public void _Detach()
        {
            parent = null;
        }

        /// <inheritdoc/>
        public abstract bool _Load(JObject jObject, bool reload = false, bool setType = true);

        /// <summary>
        /// Associates a new <see cref="JObject"/> instance with the mapper.
        /// </summary>
        /// <param name="newObject">The new <see cref="JObject"/>.</param>
        protected void _Load(JObject newObject)
        {
            Covenant.Requires<ArgumentNullException>(newObject != null);

            if (object.ReferenceEquals(JObject, newObject))
            {
                return; // Nothing changed
            }

            // Detach the property changed listener from the original
            // instance, if there is one.

            if (JObject != null)
            {
                JObject.PropertyChanged -= OnJsonPropertyChanged;
            }

            // ...and wire up the new instance.

            JObject = newObject;
            JObject.PropertyChanged += OnJsonPropertyChanged;
        }

        /// <inheritdoc/>
        public void _OnChanged()
        {
            Changed?.Invoke(this, EventArgs.Empty);
        }

        /// <summary>
        /// Maps a <see cref="SimpleMapper{TValue}"/> to the corresponding <see cref="JProperty"/>
        /// in the current <see cref="JObject"/>.  A <see cref="JProperty"/> will be created if
        /// one doesn't already exist (with a default value).
        /// </summary>
        /// <typeparam name="TValue">The property value type.</typeparam>
        /// <param name="propertyMapper">The property mapper.</param>
        /// <param name="reload">Optionally specifies that the model is being reloaded.</param>
        /// <returns><c>true</c> if the mapped value changed.</returns>
        /// <remarks>
        /// <note>
        /// Pass <paramref name="reload"/>=<c>true</c> to reload data from a new 
        /// <see cref="JObject"/> into the model.  In this case, the implementation
        /// must ensure that all appropriate property and collection change notifications 
        /// are raised to ensure that any listening UX elements will be updated.
        /// </note>
        /// </remarks>
        protected bool MapProperty<TValue>(ref SimpleMapper<TValue> propertyMapper, bool reload = false)
        {
            var jsonName  = propertyMapper.JsonName;
            var jProperty = JObject.Properties().SingleOrDefault(p => p.Name == jsonName);

            if (jProperty == null)
            {
                jProperty = new JProperty(propertyMapper.JsonName, default);

                JObject.Add(jProperty);
            }

            return propertyMapper.Load(jProperty, reload);
        }

        /// <summary>
        /// Maps an <see cref="EntityMapper{TValue}"/> to the corresponding <see cref="JProperty"/>
        /// in the current <see cref="JObject"/>.  A <see cref="JProperty"/> will be created if
        /// one doesn't already exist (with a default value).
        /// </summary>
        /// <typeparam name="TEntity">The property value type.</typeparam>
        /// <param name="propertyMapper">The property mapper.</param>
        /// <param name="reload">Optionally specifies that the model is being reloaded.</param>
        /// <returns><c>true</c> if the mapped value changed.</returns>
        /// <remarks>
        /// <note>
        /// Pass <paramref name="reload"/>=<c>true</c> to reload data from a new 
        /// <see cref="JObject"/> into the model.  In this case, the implementation
        /// must ensure that all appropriate property and collection change notifications 
        /// are raised to ensure that any listening UX elements will be updated.
        /// </note>
        /// </remarks>
        protected bool MapProperty<TEntity>(ref EntityMapper<TEntity> propertyMapper, bool reload = false)
            where TEntity : class, DynamicData.IDynamicEntity, new()
        {
            var jsonName  = propertyMapper.JsonName;
            var jProperty = JObject.Properties().SingleOrDefault(p => p.Name == jsonName);

            if (jProperty == null)
            {
                jProperty = new JProperty(propertyMapper.JsonName, default);

                JObject.Add(jProperty);
            }

            return propertyMapper.Load(jProperty, reload);
        }

        /// <summary>
        /// Maps a <see cref="LinkMapper{TValue}"/> to the corresponding <see cref="JProperty"/>
        /// in the current <see cref="JObject"/>.  A <see cref="JProperty"/> will be created if
        /// one doesn't already exist (with a default value).
        /// </summary>
        /// <typeparam name="TEntity">The property value type.</typeparam>
        /// <param name="propertyMapper">The property mapper.</param>
        /// <param name="reload">Optionally specifies that the model is being reloaded.</param>
        /// <returns><c>true</c> if the mapped value changed.</returns>
        /// <remarks>
        /// <note>
        /// Pass <paramref name="reload"/>=<c>true</c> to reload data from a new 
        /// <see cref="JObject"/> into the model.  In this case, the implementation
        /// must ensure that all appropriate property and collection change notifications 
        /// are raised to ensure that any listening UX elements will be updated.
        /// </note>
        /// </remarks>
        protected bool MapProperty<TEntity>(ref LinkMapper<TEntity> propertyMapper, bool reload = false)
            where TEntity : class, IDynamicEntity, new()
        {
            var jsonName  = propertyMapper.JsonName;
            var jProperty = JObject.Properties().SingleOrDefault(p => p.Name == jsonName);

            if (jProperty == null)
            {
                jProperty = new JProperty(propertyMapper.JsonName, default);

                JObject.Add(jProperty);
            }

            return propertyMapper.Load(jProperty, reload);
        }

        /// <summary>
        /// Maps a <see cref="ListMapper{TValue}"/> to the corresponding <see cref="JProperty"/>
        /// in the current <see cref="JObject"/>.  A <see cref="JProperty"/> will be created if
        /// one doesn't already exist (with a default value).
        /// </summary>
        /// <typeparam name="TItem">The property values list item type.</typeparam>
        /// <param name="propertyMapper">The property mapper.</param>
        /// <param name="reload">Optionally specifies that the model is being reloaded.</param>
        /// <returns><c>true</c> if the mapped value changed.</returns>
        /// <remarks>
        /// <note>
        /// Pass <paramref name="reload"/>=<c>true</c> to reload data from a new 
        /// <see cref="JObject"/> into the model.  In this case, the implementation
        /// must ensure that all appropriate property and collection change notifications 
        /// are raised to ensure that any listening UX elements will be updated.
        /// </note>
        /// </remarks>
        protected bool MapProperty<TItem>(ref ListMapper<TItem> propertyMapper, bool reload = false)
        {
            var jsonName  = propertyMapper.JsonName;
            var jProperty = JObject.Properties().SingleOrDefault(p => p.Name == jsonName);

            if (jProperty == null)
            {
                jProperty = new JProperty(propertyMapper.JsonName, default);

                JObject.Add(jProperty);
            }

            return propertyMapper.Load(jProperty, reload);
        }

        /// <summary>
        /// Maps an <see cref="EntityListMapper{TValue}"/> to the corresponding <see cref="JProperty"/>
        /// in the current <see cref="JObject"/>.  A <see cref="JProperty"/> will be created if
        /// one doesn't already exist (with a default value).
        /// </summary>
        /// <typeparam name="TEntity">The property values list item type.</typeparam>
        /// <param name="propertyMapper">The property mapper.</param>
        /// <param name="reload">Optionally specifies that the model is being reloaded.</param>
        /// <returns><c>true</c> if the mapped value changed.</returns>
        /// <remarks>
        /// <note>
        /// Pass <paramref name="reload"/>=<c>true</c> to reload data from a new 
        /// <see cref="JObject"/> into the model.  In this case, the implementation
        /// must ensure that all appropriate property and collection change notifications 
        /// are raised to ensure that any listening UX elements will be updated.
        /// </note>
        /// </remarks>
        protected bool MapProperty<TEntity>(ref EntityListMapper<TEntity> propertyMapper, bool reload = false)
            where TEntity : class, IDynamicEntity, new()
        {
            var jsonName  = propertyMapper.JsonName;
            var jProperty = JObject.Properties().SingleOrDefault(p => p.Name == jsonName);

            if (jProperty == null)
            {
                jProperty = new JProperty(propertyMapper.JsonName, default);

                JObject.Add(jProperty);
            }

            return propertyMapper.Load(jProperty, reload);
        }

        /// <summary>
        /// Maps a <see cref="LinkListMapper{TValue}"/> to the corresponding <see cref="JProperty"/>
        /// in the current <see cref="JObject"/>.  A <see cref="JProperty"/> will be created if
        /// one doesn't already exist (with a default value).
        /// </summary>
        /// <typeparam name="TEntity">The property value's list item type.</typeparam>
        /// <param name="propertyMapper">The property mapper.</param>
        /// <param name="reload">Optionally specifies that the model is being reloaded.</param>
        /// <returns><c>true</c> if the mapped value changed.</returns>
        /// <remarks>
        /// <note>
        /// Pass <paramref name="reload"/>=<c>true</c> to reload data from a new 
        /// <see cref="JObject"/> into the model.  In this case, the implementation
        /// must ensure that all appropriate property and collection change notifications 
        /// are raised to ensure that any listening UX elements will be updated.
        /// </note>
        /// </remarks>
        protected bool MapProperty<TEntity>(ref LinkListMapper<TEntity> propertyMapper, bool reload = false)
            where TEntity : class, IDynamicEntity, new()
        {
            var jsonName  = propertyMapper.JsonName;
            var jProperty = JObject.Properties().SingleOrDefault(p => p.Name == jsonName);

            if (jProperty == null)
            {
                jProperty = new JProperty(propertyMapper.JsonName, default);

                JObject.Add(jProperty);
            }

            return propertyMapper.Load(jProperty, reload);
        }

        /// <summary>
        /// Maps an <see cref="DocLinkMapper{TValue}"/> to the corresponding <see cref="JProperty"/>
        /// in the current <see cref="JObject"/>.  A <see cref="JProperty"/> will be created if
        /// one doesn't already exist (with a default value).
        /// </summary>
        /// <typeparam name="TDocument">The property values list item type.</typeparam>
        /// <param name="propertyMapper">The property mapper.</param>
        /// <param name="reload">Optionally specifies that the model is being reloaded.</param>
        /// <returns><c>true</c> if the mapped value changed.</returns>
        /// <remarks>
        /// <note>
        /// Pass <paramref name="reload"/>=<c>true</c> to reload data from a new 
        /// <see cref="JObject"/> into the model.  In this case, the implementation
        /// must ensure that all appropriate property and collection change notifications 
        /// are raised to ensure that any listening UX elements will be updated.
        /// </note>
        /// </remarks>
        protected bool MapProperty<TDocument>(ref DocLinkMapper<TDocument> propertyMapper, bool reload = false)
            where TDocument : class, IDynamicDocument
        {
            var jsonName  = propertyMapper.JsonName;
            var jProperty = JObject.Properties().SingleOrDefault(p => p.Name == jsonName);

            if (jProperty == null)
            {
                jProperty = new JProperty(propertyMapper.JsonName, default);

                JObject.Add(jProperty);
            }

            return propertyMapper.Load(jProperty, reload);
        }

        /// <summary>
        /// Maps a <see cref="DocListMapper{TValue}"/> to the corresponding <see cref="JProperty"/>
        /// in the current <see cref="JObject"/>.  A <see cref="JProperty"/> will be created if
        /// one doesn't already exist (with a default value).
        /// </summary>
        /// <typeparam name="TDocument">The property value's list item type.</typeparam>
        /// <param name="propertyMapper">The property mapper.</param>
        /// <param name="reload">Optionally specifies that the model is being reloaded.</param>
        /// <returns><c>true</c> if the mapped value changed.</returns>
        /// <remarks>
        /// <note>
        /// Pass <paramref name="reload"/>=<c>true</c> to reload data from a new 
        /// <see cref="JObject"/> into the model.  In this case, the implementation
        /// must ensure that all appropriate property and collection change notifications 
        /// are raised to ensure that any listening UX elements will be updated.
        /// </note>
        /// </remarks>
        protected bool MapProperty<TDocument>(ref DocListMapper<TDocument> propertyMapper, bool reload = false)
            where TDocument : class, IDynamicDocument
        {
            var jsonName  = propertyMapper.JsonName;
            var jProperty = JObject.Properties().SingleOrDefault(p => p.Name == jsonName);

            if (jProperty == null)
            {
                jProperty = new JProperty(propertyMapper.JsonName, default);

                JObject.Add(jProperty);
            }

            return propertyMapper.Load(jProperty, reload);
        }

        /// <summary>
        /// Called when the mapped <see cref="JObject"/> raises its property changed event.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="args">The arguments.</param>
        private void OnJsonPropertyChanged(object sender, PropertyChangedEventArgs args)
        {
            // Map the JSON property name to the equivalent entity property name
            // and then raise the entoty's property changed event.

            if (string.IsNullOrEmpty(args.PropertyName))
            {
                // Relay null or empty property names.

                self._OnPropertyChanged(args.PropertyName);
            }
            else
            {
                string entityPropertyName;

                if (propertyNameMap.TryGetValue(args.PropertyName, out entityPropertyName))
                {
                    self._OnPropertyChanged(entityPropertyName);
                }
            }

            // Walk the entity tree from this point up to the root, raising
            // the [EntityChanged] events at every level.

            var node = this;

            while (true)
            {
                node.self._OnChanged();

                if (node.parent == null)
                {
                    break;
                }

                node = (DynamicEntity)node.parent;
            }
        }

        /// <inheritdoc/>
        void IDynamicEntity._OnPropertyChanged(string propertyName)
        {
            OnPropertyChanged(propertyName);
            _OnChanged();
        }
    }
}
