//-----------------------------------------------------------------------------
// FILE:	    VpnCaFiles.cs
// CONTRIBUTOR: Jeff Lill
// COPYRIGHT:	Copyright (c) 2016-2018 by neonFORGE, LLC.  All rights reserved.

using ICSharpCode.SharpZipLib.Zip;
using Neon.Common;
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace Neon.Hive
{
    /// <summary>
    /// Manages the VPN certificate authority files  These files are packaged into a
    /// ZIP archive, encrypted and then stored in the hive's Vault.
    /// </summary>
    public sealed class VpnCaFiles : IDisposable
    {
        //---------------------------------------------------------------------
        // Static members

        /// <summary>
        /// Creates a <see cref="VpnCaFiles"/> instances by loading the files in
        /// a file system folder.
        /// </summary>
        /// <param name="folderPath">The folder path.</param>
        /// <returns>The <see cref="VpnCaFiles"/> instance.</returns>
        public static VpnCaFiles LoadFolder(string folderPath)
        {
            var stream = new MemoryStream();
            var zip    = new ZipFile(stream);

            zip.BeginUpdate();

            // Note that we know that the directory structure is flat.

            foreach (var path in Directory.GetFiles(folderPath, "*.*", SearchOption.TopDirectoryOnly))
            {
                var data = new StaticBytesDataSource(File.ReadAllBytes(path));

                zip.Add(data, Path.GetFileName(path));
            }

            zip.CommitUpdate();

            return new VpnCaFiles(zip, stream, updating: true);
        }

        /// <summary>
        /// Creates a <see cref="VpnCaFiles"/> instances by loading 
        /// a ZIP archive from an optionally encrypted byte array.
        /// </summary>
        /// <param name="zipBytes">The serialized ZIP archive.</param>
        /// <param name="key">The optional AES encryption key generated by <see cref="GenerateKey"/>.</param>
        /// <returns>The <see cref="VpnCaFiles"/> instance.</returns>
        public static VpnCaFiles LoadZip(byte[] zipBytes, string key = null)
        {
            var stream = new MemoryStream();

            stream.Write(zipBytes);
            stream.Position = 0;

            return new VpnCaFiles(new ZipFile(stream), stream);
        }

        //---------------------------------------------------------------------
        // Encryption helpers.
        //
        // We're going to use 256-bit AES encryption to secure the certificate authority
        // files using the key and initialization vector returned by [GenerateKey()].
        // The data before encryption will be laid out as:
        //
        //      +--------------------+
        //      |     Magic Number   |  4 bytes
        //      +--------------------+
        //      | Cryptographic Salt |  8 bytes
        //      +--------------------+
        //      |                    |
        //      |                    |
        //      |    ZIP Archive     |
        //      |                    |
        //      |                    |
        //      +--------------------+
        //
        // Where the 4 byte magic number is used to verify successful decryption, the 8
        // bytes of cryptographic salt will make it much harder for brute force attacks.
        // The ZIP archive bytes follow the 12 header bytes.

        private static readonly byte[] magic = new byte[] { 0x71, 0xac, 0x19, 0xe2 };

        /// <summary>
        /// Generates an AES encryption key/initialization vector suitable for 
        /// encrypting the certificate authority files.
        /// </summary>
        /// <returns>The key and initialization vector.</returns>
        public static string GenerateKey()
        {
            using (var aes = Aes.Create())
            {
                aes.KeySize = 256;
                aes.GenerateKey();
                aes.GenerateIV();

                return $"{Convert.ToBase64String(aes.Key)}:{Convert.ToBase64String(aes.IV)}";
            }
        }

        /// <summary>
        /// Splits the encryption key into its key and initialization vector components.
        /// </summary>
        /// <param name="key">An encryption key generated by <see cref="GenerateKey"/>.</param>
        /// <returns>The key components.</returns>
        private static (byte[] Key, byte[] IV) SplitKey(string key)
        {
            Covenant.Requires<ArgumentNullException>(!string.IsNullOrEmpty(key));

            var pos = key.IndexOf(':');

            if (pos == -1)
            {
                throw new ArgumentException("Invalid encryption key.");
            }

            var keyPart = key.Substring(0, pos);
            var ivPart  = key.Substring(pos + 1);

            return (Convert.FromBase64String(keyPart), Convert.FromBase64String(ivPart));
        }

        /// <summary>
        /// Encrypts a certificate authority ZIP archive.
        /// </summary>
        /// <param name="zipBytes">The unencrypted serialized ZIP archive.</param>
        /// <param name="key">An encryption key generated by <see cref="GenerateKey"/>.</param>
        /// <returns>The encrypted bytes.</returns>
        private static byte[] Encrypt(byte[] zipBytes, string key)
        {
            var keyParts = SplitKey(key);

            using (var aes = Aes.Create())
            {
                using (var decryptedInput = new MemoryStream())
                {
                    decryptedInput.Write(magic);
                    decryptedInput.Write(NeonHelper.RandBytes(8));
                    decryptedInput.Write(zipBytes);
                    decryptedInput.Position = 0;

                    using (var encryptedOutput = new MemoryStream())
                    {
                        using (var encryptor = aes.CreateEncryptor(keyParts.Key, keyParts.IV))
                        {
                            var inputBuffer  = new byte[encryptor.InputBlockSize];
                            var outputBuffer = new byte[encryptor.OutputBlockSize];
                            int cbInput;
                            int cbOutput;

                            while (true)
                            {
                                cbInput = decryptedInput.Read(inputBuffer, 0, inputBuffer.Length);

                                if (cbInput == 0)
                                {
                                    break;
                                }

                                if (cbInput == inputBuffer.Length)
                                {
                                    cbOutput = encryptor.TransformBlock(inputBuffer, 0, cbInput, outputBuffer, 0);
                                    encryptedOutput.Write(outputBuffer, 0, cbOutput);
                                }
                                else
                                {
                                    break;
                                }
                            }

                            var finalBlock = encryptor.TransformFinalBlock(inputBuffer, 0, cbInput);

                            if (finalBlock != null && finalBlock.Length > 0)
                            {
                                encryptedOutput.Write(finalBlock);
                            }
                        }

                        return encryptedOutput.ToArray();
                    }
                }
            }
        }

        /// <summary>
        /// Decrypts a certificate authority ZIP archive.
        /// </summary>
        /// <param name="encryptedBytes">The encrypted bytes.</param>
        /// <param name="key">An encryption key generated by <see cref="GenerateKey"/>.</param>
        /// <returns>The decrypted bytes.</returns>
        private static byte[] Decrypt(byte[] encryptedBytes, string key)
        {
            var keyParts = SplitKey(key);

            using (var aes = Aes.Create())
            {
                using (var encryptedInput = new MemoryStream(encryptedBytes))
                {
                    using (var decryptedOutput = new MemoryStream())
                    {
                        using (var decryptor = aes.CreateDecryptor(keyParts.Key, keyParts.IV))
                        {
                            var inputBuffer  = new byte[decryptor.InputBlockSize];
                            var outputBuffer = new byte[decryptor.OutputBlockSize];
                            int cbInput;
                            int cbOutput;

                            while (true)
                            {
                                cbInput = encryptedInput.Read(inputBuffer, 0, inputBuffer.Length);

                                if (cbInput == 0)
                                {
                                    break;
                                }

                                if (cbInput == inputBuffer.Length)
                                {
                                    cbOutput = decryptor.TransformBlock(inputBuffer, 0, cbInput, outputBuffer, 0);
                                    decryptedOutput.Write(outputBuffer, 0, cbOutput);
                                }
                                else
                                {
                                    break;
                                }
                            }

                            var finalBlock = decryptor.TransformFinalBlock(inputBuffer, 0, cbInput);

                            if (finalBlock != null && finalBlock.Length > 0)
                            {
                                decryptedOutput.Write(finalBlock);
                            }
                        }

                        // Verify the magic number.

                        const string decryptionError = "VPN certificate authority decryption failed.";

                        var decryptedBytes = decryptedOutput.ToArray();

                        if (decryptedBytes.Length < 12)
                        {
                            throw new Exception(decryptionError);
                        }

                        for (int i = 1; i < 4; i++)
                        {
                            if (decryptedBytes[i] != magic[i])
                            {
                                throw new Exception(decryptionError);
                            }
                        }

                        // Extract everything after the 12 byte header.

                        var zipBytes = new byte[decryptedBytes.Length - 12];

                        Array.ConstrainedCopy(decryptedBytes, 12, zipBytes, 0, zipBytes.Length);

                        return zipBytes;
                    }
                }
            }
        }

        //---------------------------------------------------------------------
        // Private members

        private ZipFile         zip;
        private MemoryStream    stream;
        private bool            updated;

        /// <summary>
        /// Static constructor.
        /// </summary>
        /// <param name="zip">The ZIP archive.</param>
        /// <param name="stream">The backing stream.</param>
        /// <param name="updating">Indicates that the zip archive has pending updates.</param>
        private VpnCaFiles(ZipFile zip, MemoryStream stream, bool updating = false)
        {
            Covenant.Requires<ArgumentNullException>(zip != null);
            Covenant.Requires<ArgumentNullException>(stream != null);

            this.zip    = zip;
            this.stream = stream;
        }

        /// <summary>
        /// Releases any resources associated with the instance.
        /// </summary>
        public void Dispose()
        {
            if (zip != null)
            {
                zip.Close();
                zip = null;
            }

            if (stream != null)
            {
                stream.Dispose();
                stream = null;
            }
        }

        /// <summary>
        /// Returns the underlying <see cref="ZipFile"/>.
        /// </summary>
        public ZipFile Zip
        {
            get { return zip; }
        }

        /// <summary>
        /// Returns the contents of the named file.
        /// </summary>
        /// <param name="fileName">The file contents certificate.</param>
        public string GetFile(string fileName)
        {
            var entry = zip.GetEntry(fileName);

            if (entry == null || !entry.IsFile)
            {
                throw new KeyNotFoundException($"[{fileName}] VPN security file was not found.");
            }

            using (var outputStream = new MemoryStream())
            {
                using (var inputStream = zip.GetInputStream(entry))
                {
                    inputStream.CopyTo(outputStream);

                    return Encoding.UTF8.GetString(outputStream.ToArray());
                }
            }
        }

        /// <summary>
        /// Adds a file with textual information to the security information.
        /// /// </summary>
        /// <param name="fileName">The file name.</param>
        /// <param name="data">The file data.</param>
        public void AddFile(string fileName, string data)
        {
            if (!updated)
            {
                zip.BeginUpdate();
                updated = true;
            }

            zip.Add(new StaticStringDataSource(data), fileName);
        }

        /// <summary>
        /// Strips any metadata off the beginning of a certificate generated by OpenSSL
        /// and returns just the PEM encoded certificate.
        /// </summary>
        /// <param name="text">The certificate text.</param>
        /// <returns>The PEM part only.</returns>
        public static string NormalizePem(string text)
        {
            var sb = new StringBuilder();

            using (var reader = new StringReader(text))
            {
                var prefix = true;

                foreach (var line in reader.Lines())
                {
                    if (prefix && line.StartsWith("-----"))
                    {
                        prefix = false;
                    }

                    if (!prefix)
                    {
                        sb.Append($"{line}\n");
                    }
                }
            }

            return sb.ToString();
        }

        /// <summary>
        /// Returns the certificate for the named entity where <b>server</b> is reserved
        /// for the OpenVPN servers, <b>ca</b> is reserved for the certificate authority,
        /// and <b>root</b> is reserved for the initial operator credentials when the
        /// hive was first provisioned.  Other names can be assigned to specific 
        /// hive operators.
        /// </summary>
        /// <param name="name">The entity name.</param>
        /// <returns>The entity's certificate.</returns>
        /// <remarks>
        /// <note>
        /// This method strips out the extra prefix generated by OpenSSL before the 
        /// actual certificate part.
        /// </note>
        /// </remarks>
        public string GetCert(string name)
        {
            return NormalizePem(GetFile($"{name}.crt"));
        }

        /// <summary>
        /// Returns the private key for the named entity where <b>server</b> is reserved
        /// for the OpenVPN servers, <b>ca</b> is reserved for the certificate authority,
        /// and <b>root</b> is reserved for the initial operator credentials when the
        /// hive was first provisioned.  Other names can be assigned to specific 
        /// hive operators.
        /// </summary>
        /// <param name="name">The entity name.</param>
        /// <returns>The entity's private key.</returns>
        public string GetKey(string name)
        {
            return GetFile($"{name}.key");
        }

        /// <summary>
        /// Returns the Diffie Hellman parameters used by OpenVPN servers.
        /// </summary>
        /// <returns></returns>
        public string GetDHParam()
        {
            return GetFile("dhparam.pem");
        }

        /// <summary>
        /// Returns the shared TLS authentication key used to provide DOS protection.
        /// </summary>
        /// <returns></returns>
        public string GetTaKey()
        {
            return GetFile("ta.key");
        }

        /// <summary>
        /// Serializes and optionally encrypts the certificate authority files.
        /// </summary>
        /// <param name="key">The optional AES encryption key generated by <see cref="GenerateKey"/>.</param>
        /// <returns>The ZIP archive bytes.</returns>
        public byte[] ToZipBytes(string key = null)
        {
            if (updated)
            {
                zip.CommitUpdate();
            }

            return stream.ToArray();
        }

        /// <summary>
        /// Extracts the files to a file system folder.
        /// </summary>
        /// <param name="folderPath">Ther target folder path.</param>
        public void Extract(string folderPath)
        {
            Directory.CreateDirectory(folderPath);

            foreach (ZipEntry entry in zip)
            {
                if (entry.IsFile)
                {
                    using (var input = zip.GetInputStream(entry))
                    {
                        using (var output = new FileStream(Path.Combine(folderPath, entry.Name), FileMode.Create, FileAccess.ReadWrite))
                        {
                            input.CopyTo(output);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Removes any unnecessary certificate authority files.
        /// </summary>
        public void Clean()
        {
            zip.BeginUpdate();

            foreach (ZipEntry entry in zip)
            {
                var name = entry.Name;

                // We can delete any certificate requests.

                if (name.EndsWith(".req"))
                {
                    zip.Delete(name);
                }

                // We can delete all private key files except for the CA and OpenVPN server keys.

                if (name.EndsWith(".key") && name != "server.key" && name != "ca.key")
                {
                    zip.Delete(name);
                }
            }

            zip.CommitUpdate();
        }
    }
}
